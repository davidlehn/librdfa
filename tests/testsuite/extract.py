##
# This is the rdfa2rdf web service for the librdfa libraryf. 
# License: GNU Lesser GPL
# @author Manu Sporny
import os, os.path
from urllib2 import urlopen
import urllib
import rdfa

##
# Called whenever a triple is generated by the underlying implementation.
#
# @param rdf the rdf object to use when storing data.
# @param subject the subject of the triple.
# @param predicate the predicate for the triple.
# @param obj the object of the triple.
# @param object_type the type for the object in the triple.
# @param datatype the datatype for the object in the triple.
# @param language the language for the object in the triple.
def handle_triple(rdf, subject, predicate, obj, object_type, datatype,
                  language):
    
    if(object_type == rdfa.RDF_TYPE_NAMESPACE_PREFIX):
        rdf['namespaces'][predicate] = obj
    else:
        rdf['triples'].append(
            (subject, predicate, obj, object_type, datatype, language))
        
##
# Called whenever the processing buffer for the C-side needs to be re-filled.
#
# @param dataFile the file-like object to use when reading in the data stream.
# @param bufferSize the size of the buffer to return. Returning anything less
#                   than bufferSize will halt execution after the returned
#                   buffer has been processed.
def handle_buffer(dataFile, bufferSize):
    return dataFile.read()

##
# Applies the namespaces to the given string in an attempt to shorten the
# string.
#
# @param namespaces the list of namespaces to use.
# @param iri the IRI to prefix.
#
# @return the prefixed IRI if it is prefixable.
def prefix_namespace(namespaces, iri):
    rval = iri

    for key, value in namespaces.items():
        rval = rval.replace(value, key + ":")

    return rval

##
# Prints RDF/XML given an object with pre-defined namespaces and triples.
#
# @param rdf the rdf dictionary object that contains namespaces and triples.
def print_rdf(req, rdf):
    req.content_type = 'application/rdf+xml'
    
    req.write('<?xml version="1.0" encoding="utf-8"?>')
    req.write('<rdf:RDF')
    req.write(' xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"')

    for prefix, uri in rdf['namespaces'].items():
        req.write(" xmlns:%s=\"%s\"" % (prefix, uri))

    req.write('>')

    for triple in rdf['triples']:
        subject = triple[0]
        predicate = prefix_namespace(rdf['namespaces'], triple[1])
        obj = triple[2]
        obj_type = triple[3]
        datatype = triple[4]
        language = triple[5]
        desc = "<rdf:Description rdf:about=\"%s\">\n" % (subject)

        if(obj_type == rdfa.RDF_TYPE_PLAIN_LITERAL):
            desc += " <%s>%s</%s>\n" % (predicate, obj, predicate)
        elif(obj_type == rdfa.RDF_TYPE_IRI):
            desc += " <%s rdf:resource=\"%s\"/>\n" % (predicate, obj)
        elif(obj_type == rdfa.RDF_TYPE_TYPED_LITERAL):
            desc += " <%s rdf:datatype=\"%s\">%s</%s>\n" % \
                (predicate, datatype, obj, prediciate)
        elif(obj_type == rdfa.RDF_TYPE_XML_LITERAL):
            desc += " <%s rdf:datatype=\"%s\">%s</%s>\n" % \
                (predicate,
                 "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral",
                 obj, predicate)
        else:
            desc += " <%s>%s</%s>\n" %(predicate, "UNKNOWN LITERAL", predicate)
        desc += '</rdf:Description>'
        req.write(desc)
        
    req.write('</rdf:RDF>')

##
# Extracts RDF from the given URL and dumps it to the screen.
#
# @param req the HTTP response to write to.
# @param url the URL to retrieve and parse.
def rdfa2rdf(req, url):
    command = "/usr/bin/python /usr/local/websites/rdfa.digitalbazaar.com/librdfa/rdfa2rdf.py %s" % (url,)
    output = os.popen(command, "r")
    #output = os.popen("ls -la", "r")
    req.content_type = 'application/rdf+xml'
    req.write(output.read())
    return

    #
    # Open the proper file stream and initialize the parser using the URL
    dataFile = urlopen(url)
    parser = rdfa.RdfaParser(url)

    # Create the RDF dictionary that will be used by the triple handler
    # callback
    rdf = {}
    rdf['namespaces'] = {}
    rdf['triples'] = []

    # Setup the parser
    parser.setTripleHandler(handle_triple, rdf)
    #parser.setBufferHandler(handle_buffer, dataFile)

    # Parse the document
    #parser.parse()

    # Close the datafile
    dataFile.close()

    # Print the RDF to stdout
    #print_rdf(req, rdf)

    req.write("JACK")
    
##
# The handler function is what is called whenever an apache call is made.
#
# @param req the HTTP request.
#
# @return always apache.OK
def handler(req):
    # File that runs an apache test.
    from mod_python import apache
  
    puri = req.parsed_uri
    service = puri[-3]
    argstr = puri[-2]
    args = {}

    # Convert all of the arguments from their URL-encoded value to normal text
    if(argstr and len(argstr) > 0):
        for kv in puri[-2].split("&"):
            key, value = kv.split("=")
            args[urllib.unquote(key)] = urllib.unquote(value)

    # Retrieve all of the unit tests from the W3C website
    if(service == "/librdfa/rdfa2rdf.py"):
        if(args.has_key('uri')):
            uri = args['uri']
            rdfa2rdf(req, uri)
        else:
            req.content_type = 'text/html'
            req.write("<b>ERROR: URI was not specified in request URL</b>")
    else:
        req.content_type = 'text/html'
        req.write("<b>ERROR: Unknown rdfa2rdf service</b>")
        
    return apache.OK
