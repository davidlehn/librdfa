#!/usr/bin/env python
# 
# This file is part of librdfa.
# 
# librdfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 2 of the
# License, or (at your option) any later version.
#
# librdfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with librdfa. If not, see <http://www.gnu.org/licenses/>.
# 
# Reads in an XHTML+RDFa file and outputs the triples generated by the file
# in N3 format.
import sys, os, urllib2
sys.path += ("../python/dist/linux",)
import rdfa

URL_TYPE_HTTP = 1
URL_TYPE_FILE = 2

##
# Called whenever a triple is generated by the underlying implementation.
#
# @param rdf the rdf object to use when storing data.
# @param subject the subject of the triple.
# @param predicate the predicate for the triple.
# @param obj the object of the triple.
# @param objectType the type for the object in the triple.
# @param dataType the dataType for the object in the triple.
# @param language the language for the object in the triple.
def handleTriple(rdf, subject, predicate, obj, objectType, dataType,
                  language):
    
    if(objectType == rdfa.RDF_TYPE_NAMESPACE_PREFIX):
        rdf['namespaces'][predicate] = obj
    else:
        rdf['triples'].append(
            (subject, predicate, obj, objectType, dataType, language))
        
##
# Called whenever the processing buffer for the C-side needs to be re-filled.
#
# @param dataFile the file-like object to use when reading in the data stream.
# @param bufferSize the size of the buffer to return. Returning anything less
#                   than bufferSize will halt execution after the returned
#                   buffer has been processed.
def fillBuffer(dataFile, bufferSize):
    return dataFile.read()

##
# Applies the namespaces to the given string in an attempt to shorten the
# string.
#
# @param namespaces the list of namespaces to use.
# @param iri the IRI to prefix.
#
# @return the prefixed IRI if it is prefixable.
def prefixNamespace(namespaces, iri):
    rval = iri

    for key, value in namespaces.items():
        rval = rval.replace(value, key + ":")

    return rval

##
# Gets a set of triples from a list given a subject.
#
# @param subject the subject to use when retrieving the list of triples.
# @param triples the list of triples to search for the given subject.
#
# @return a list of triples based on the given subject.
def getTriplesBySubject(subject, triples):
    rval = []

    for item in triples:
        if(item[0] == subject):
            rval.append(item)

    return rval

##
# Deletes a set of triples from the given list given a subject.
#
# @param subject the subject to use when deleting the list of triples.
# @param triples the list of triples to search when deleting triples.
#
# @return a list of triples that have the given subject removed from them
def deleteTriplesBySubject(subject, triples):
    rval = []

    for item in triples:
        if(item[0] != subject):
            rval.append(item)

    return rval

##
# Prints a set of triples, grouping them by subject.
#
# @param triples the list of triples that must all have the same subject.
def printTriplesBySubject(namespaces, triples):
    subject = triples[0][0]
    subjectType = "rdf:Description"

    # Figure out what the subject of the triple should be, and then 
    for triple in triples:
        if(triple[1] == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"):
            subjectType = prefixNamespace(namespaces, triple[2])
            break

    print " <%s rdf:about=\"%s\">" % (subjectType, subject)

    for triple in triples:
        predicate = prefixNamespace(namespaces, triple[1])
        obj = triple[2]
        objectType = triple[3]
        dataType = triple[4]
        language = triple[5]
        tripleText = ""
        lang = ""
        
        if(language):
            lang = " xml:lang=\"%s\"" % (language,)

        if(predicate == "rdf:type"):
            continue
        elif(objectType == rdfa.RDF_TYPE_PLAIN_LITERAL):
            tripleText += "  <%s%s>%s</%s>" % \
                (predicate, lang, obj, predicate)
        elif(objectType == rdfa.RDF_TYPE_IRI):
            tripleText += "  <%s rdf:resource=\"%s\"%s/>" % \
                (predicate, obj, lang)
        elif(objectType == rdfa.RDF_TYPE_TYPED_LITERAL):
            tripleText += "  <%s rdf:datatype=\"%s\"%s>%s</%s>" % \
                (predicate, dataType, lang, obj, predicate)
        elif(objectType == rdfa.RDF_TYPE_XML_LITERAL):
            tripleText += \
                "  <%s rdf:datatype=\"%s\"%s><![CDATA[%s]]></%s>" % \
                (predicate,
                 "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral",
                 lang, obj, predicate)
        else:
            tripleText += " <%s>%s</%s>\n" % \
                (predicate, "UNKNOWN LITERAL", predicate)
        print tripleText

    print " </%s>" % (subjectType)

##
# Prints RDF/XML given an object with pre-defined namespaces and triples.
#
# @param rdf the rdf dictionary object that contains namespaces and triples.
def printRdf(rdf):
    print '<?xml version="1.0" encoding="utf-8"?>'
    print '<rdf:RDF'

    # Append the RDF namespace and print the prefix namespace mappings
    rdf['namespaces']['xh1'] = "http://www.w3.org/1999/xhtml/vocab#"
    rdf['namespaces']['rdf'] = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    for prefix, uri in rdf['namespaces'].items():
        print " xmlns:%s=\"%s\"" % (prefix, uri)

    print '>'

    # Print each subject-based triple to the screen
    triples = rdf['triples']
    while(len(triples) > 0):
        # Get the subject and start printing triples by subject
        subject = triples[0][0]
        striples = getTriplesBySubject(subject, triples)
        triples = deleteTriplesBySubject(subject, triples)

        printTriplesBySubject(rdf['namespaces'], striples)

    print '</rdf:RDF>'

##
# The main entry point for the script.
#
# @param argv the argument list passed to the program.
# @param stdout the standard output stream assigned to the program.
# @param environ the execution environment for the program.
def main(argv, stdout, environ):
    urlType = URL_TYPE_FILE

    if((len(argv) > 1) and (len(argv[1]) > 4)):
        if(argv[1][:5] == "http:"):
            urlType = URL_TYPE_HTTP
    else:
        print "usage:", argv[0], "<file>"
        print "or"
        print "      ", argv[0], "<URL>"
        sys.exit(1)
    
    if((urlType == URL_TYPE_FILE) and (not os.path.exists(argv[1]))):
        print "File %s, does not exist" % (argv[1])
        sys.exit(1)
    if((urlType == URL_TYPE_FILE) and (not os.access(argv[1], os.R_OK))):
        print "Cannot read file named %s" % (argv[1])
        sys.exit(1)

    # Open the data file and setup the parser
    dataFile = None
    parser = None

    # Open the proper file stream and initialize the parser using the URL
    if(urlType == URL_TYPE_HTTP):
        dataFile = urllib2.urlopen(argv[1])
        parser = rdfa.RdfaParser(argv[1])
    else:
        dataFile = open(argv[1], "r")
        parser = rdfa.RdfaParser("file://" + os.path.abspath(argv[1]))

    # Create the RDF dictionary that will be used by the triple handler
    # callback
    rdf = {}
    rdf['namespaces'] = {}
    rdf['triples'] = []

    # Setup the parser
    parser.setTripleHandler(handleTriple, rdf)
    parser.setBufferHandler(fillBuffer, dataFile)

    # Parse the document
    parser.parse()

    # Close the datafile
    dataFile.close()

    # Print the RDF to stdout
    printRdf(rdf)
    
##
# Run the rdfa2n3 python application.
if __name__ == "__main__":
    main(sys.argv, sys.stdout, os.environ)
